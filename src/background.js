// Import PQueue for controlled concurrency
import PQueue from 'p-queue';
// Import the preloaded URL list generated by our crawler
import { preloadedUrls } from './url-list.js';

let isSearching = false;

// Store the abort controller for search operations
let searchAbortController = null;

chrome.action.onClicked.addListener(_tab => {
  chrome.tabs.create({
    url: 'popup.html',
  });
});

// Store the popup port when connected
let popupPort = null;

// Handle connections from popup
chrome.runtime.onConnect.addListener(port => {
  // console.log('Port connected:', port.name);
  if (port.name === 'popup') {
    popupPort = port;

    // Handle popup disconnection
    port.onDisconnect.addListener(() => {
      // console.log('Popup disconnected');
      popupPort = null;
    });

    // Listen for messages from the popup
    port.onMessage.addListener(request => {
      // console.log('Message received from popup:', request);
      if (request.action === 'search') {
        isSearching = true;
        // Create a new abort controller for this search
        searchAbortController = new AbortController();
        performSearch(request.query, searchAbortController.signal);
      } else if (request.action === 'stopSearch') {
        isSearching = false;
        // Abort any ongoing search operations
        if (searchAbortController) {
          searchAbortController.abort();
          searchAbortController = null;
        }
      }
    });
  }
});

// For backward compatibility with existing message listeners

async function performSearch(query, signal) {
  // console.log('Performing search for:', query);
  const CONCURRENCY = 10;

  // Create a new PQueue with concurrency limit
  const queue = new PQueue({ concurrency: CONCURRENCY });

  // Set up abort handling
  if (signal) {
    signal.addEventListener('abort', () => {
      queue.clear();
      queue.add(() => Promise.resolve());
      console.log('Search aborted via AbortController');
      if (popupPort) {
        popupPort.postMessage({ action: 'searchComplete' });
      }
    });
  }

  // Use our preloaded URLs instead of discovering them through parsing
  const totalLinks = preloadedUrls.length;
  let searchedLinks = 0;

  // Lowercase the query once for case-insensitive comparisons
  const queryLower = query.toLowerCase();

  // Create a regex to highlight matches efficiently
  const highlightRegex = new RegExp(query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');

  // Setup progress monitoring
  let lastProgressUpdate = Date.now();
  const PROGRESS_UPDATE_INTERVAL = 500; // 500ms between progress updates

  // Create a function to handle completed tasks
  const handleTaskCompletion = result => {
    if (!isSearching) return;

    // Increment counter for progress calculation
    searchedLinks++;

    // Calculate progress percentage
    const progress = (searchedLinks / totalLinks) * 100;

    // Throttle progress updates to avoid overwhelming the UI
    const now = Date.now();
    if (now - lastProgressUpdate >= PROGRESS_UPDATE_INTERVAL) {
      lastProgressUpdate = now;
      sendProgressUpdate(progress);
    }

    // Process results if we have matches
    if (result && result.matches && result.matches.length > 0) {
      sendSearchResults(result.matches);
    }
  };

  // Add all URLs to the queue
  for (const url of preloadedUrls) {
    if (!isSearching) break;

    // Add each URL as a task to the queue
    queue.add(() => {
      // Check if search is still active or if we've been aborted
      if (!isSearching || (signal && signal.aborted)) {
        return Promise.resolve(null);
      }

      // Pass signal to fetch operation for proper cancellation
      return fastFetchAndSearch(url, queryLower, highlightRegex, signal)
        .then(result => {
          // Skip processing if aborted during fetch
          if (signal && signal.aborted) return null;

          handleTaskCompletion(result);
          return result;
        })
        .catch(error => {
          // Don't log errors from aborted requests
          if (error.name !== 'AbortError') {
            console.error({ error });
          }

          // Only increment counter if not aborted
          if (!(signal && signal.aborted)) {
            handleTaskCompletion(null); // Still increment counter on non-abort errors
          }
          return null;
        });
    });
  }

  // Helper function to send progress updates
  function sendProgressUpdate(progress) {
    if (popupPort) {
      try {
        popupPort.postMessage({ action: 'searchProgress', progress });
      } catch (error) {
        console.error('Error sending progress via port:', error);
      }
    }
  }

  // Helper function to send search results
  function sendSearchResults(results) {
    if (popupPort) {
      try {
        popupPort.postMessage({ action: 'searchResult', results });
      } catch (error) {
        console.error('Exception sending search results:', error);
      }
    }
  }

  // Wait for all tasks to complete or for search to be stopped
  try {
    // onIdle returns a promise that resolves when the queue is empty
    await queue.onIdle();
  } catch (error) {
    console.error('Error waiting for queue to complete:', error);
  } finally {
    // Ensure final progress update
    sendProgressUpdate(100);

    // Send search complete message
    if (popupPort) {
      try {
        popupPort.postMessage({ action: 'searchComplete' });
      } catch (_) {
        // Ignore errors if the port is disconnected
      }
    }
  }
}

// Function to quickly search text directly in HTML using String.prototype.matchAll
async function fastFetchAndSearch(url, queryLower, highlightRegex, parentSignal) {
  if (!isSearching || (parentSignal && parentSignal.aborted)) return null;

  try {
    // Use AbortController for timeout and connect it with the parent signal
    const controller = new AbortController();
    const signal = controller.signal;
    const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout

    // Create a combined signal that aborts if either parent or timeout triggers
    const fetchSignal = signal;

    if (parentSignal) {
      // If parent already aborted, return immediately
      if (parentSignal.aborted) {
        clearTimeout(timeoutId);
        return null;
      }

      // Handle parent abort during fetch
      const abortHandler = () => {
        controller.abort();
        clearTimeout(timeoutId);
      };

      parentSignal.addEventListener('abort', abortHandler, { once: true });
    }

    const response = await fetch(url, { signal });
    clearTimeout(timeoutId);

    // Skip non-HTML content
    const contentType = response.headers.get('Content-Type') || '';
    if (!contentType.includes('text/html')) {
      return { matches: [] };
    }

    const html = await response.text();

    // Quick check if the query exists in the page
    if (!html.toLowerCase().includes(queryLower)) {
      return { matches: [] };
    }

    // Extract title using regex instead of DOM parsing
    const titleMatch = /<title>(.*?)<\/title>/i.exec(html);
    const title = titleMatch ? titleMatch[1] : url.split('/').pop().replace('.htm', '');

    // Escape the query for use in regex (handle special regex characters)
    const escapedQuery = queryLower.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    // Create a regex to find the query, making sure it's not inside a tag attribute
    // Negative lookbehind ensures we don't match inside attributes
    // Negative lookahead ensures we don't match partial words
    const matchRegex = new RegExp(`(?<![='"\\w])${escapedQuery}(?!['"\\w])`, 'gi');

    // Find all matches using matchAll
    const matchIterator = html.matchAll(matchRegex);
    const matches = Array.from(matchIterator);

    // Extract full sentences for each match (up to sentence boundaries)
    const sentenceMatches = [];

    for (const match of matches) {
      const matchIndex = match.index;

      // Look for sentence boundaries (., !, ?) before the match
      let sentenceStart = -1;
      for (let i = 0; i < 3; i++) {
        // Try multiple punctuation marks
        const punctuation = i === 0 ? '.' : i === 1 ? '!' : '?';
        let tempStart = matchIndex;

        // Look backward for up to 300 characters to find sentence start
        while (tempStart > 0 && tempStart > matchIndex - 300) {
          tempStart--;
          // Check if we found a sentence boundary followed by a space or newline
          if (
            html[tempStart] === punctuation &&
            (html[tempStart + 1] === ' ' || html[tempStart + 1] === '\n')
          ) {
            sentenceStart = tempStart + 2; // Start after the punctuation and space
            break;
          }
        }
        if (sentenceStart !== -1) break;
      }

      // If no sentence start found, look for beginning of paragraph
      if (sentenceStart === -1) {
        let tempStart = matchIndex;
        while (tempStart > 0 && tempStart > matchIndex - 300) {
          tempStart--;
          if (html[tempStart] === '>' && tempStart < matchIndex - 1) {
            sentenceStart = tempStart + 1;
            break;
          }
        }
      }

      // If still no start found, use a reasonable offset
      if (sentenceStart === -1) {
        sentenceStart = Math.max(0, matchIndex - 100);
      }

      // Look for sentence boundaries after the match
      let sentenceEnd = -1;
      for (let i = 0; i < 3; i++) {
        const punctuation = i === 0 ? '.' : i === 1 ? '!' : '?';
        let tempEnd = matchIndex + match[0].length;

        // Look forward for up to 300 characters to find sentence end
        while (tempEnd < html.length && tempEnd < matchIndex + 300) {
          if (
            html[tempEnd] === punctuation &&
            (tempEnd + 1 === html.length || html[tempEnd + 1] === ' ' || html[tempEnd + 1] === '\n')
          ) {
            sentenceEnd = tempEnd + 1; // Include the punctuation
            break;
          }
          tempEnd++;
        }
        if (sentenceEnd !== -1) break;
      }

      // If no sentence end found, look for end of paragraph
      if (sentenceEnd === -1) {
        let tempEnd = matchIndex + match[0].length;
        while (tempEnd < html.length && tempEnd < matchIndex + 300) {
          if (html[tempEnd] === '<' && tempEnd > matchIndex + match[0].length) {
            sentenceEnd = tempEnd;
            break;
          }
          tempEnd++;
        }
      }

      // If still no end found, use a reasonable offset
      if (sentenceEnd === -1) {
        sentenceEnd = Math.min(html.length, matchIndex + match[0].length + 100);
      }

      // Extract the sentence containing the match
      const sentence = html.substring(sentenceStart, sentenceEnd);

      // Make sure the sentence isn't just HTML or an attribute value
      if (sentence.length > 20 && !sentence.includes('="') && !sentence.includes("'")) {
        sentenceMatches.push(sentence);
      }
    }

    // If we found matches, return them as a single result for this page
    if (sentenceMatches.length > 0) {
      // Remove duplicates
      const uniqueMatches = [...new Set(sentenceMatches)];

      // Highlight all occurrences of the query term in each match
      const highlightedMatches = uniqueMatches.map(match =>
        match.replace(highlightRegex, '<b>$&</b>')
      );

      return {
        matches: [
          {
            url,
            title,
            paragraph: highlightedMatches.join(' ... '),
            matchCount: uniqueMatches.length,
          },
        ],
      };
    }

    return { matches: [] };
  } catch (_) {
    return { matches: [] };
  }
}
